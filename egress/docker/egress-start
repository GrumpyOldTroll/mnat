#!/usr/bin/env python3

import argparse
import subprocess
from os.path import isfile
import sys
import time
import signal

def main(args_in):
    parser = argparse.ArgumentParser(
            description='''
This runs mnat-igmp-monitor and mnat-egress, linked by their control file.

mnat-egress notifies the server about joins it learns of from igmp-monitor.
Based on the server responses about the global-local (S,G) mappings, it
runs:
 - mnat-translate to translate the from upstream local to downstream global
   - this launches smcroutectl to join the local (S,G) on the upstream
     interface.

igmp-monitor looks at the igmp traffic to determine what's joined downstream
and notified mnat-egress by updating its control file, which mnat-egress
monitors.

If one is killed, this will kill the other and try to exit gracefully.

Since this is designed as the docker entry point, it will use docker-
specific paths by default if they are present.  This happens with:
    - /etc/mnat/ca.pem (containing a public root cert to validate the server)
    - /etc/mnat/client.pem (containing a private cert to prove identity of this client)
    - /var/run/mnat/igmp-monitor.sgs (shouldn't need export, but provides the set of joined (S,G)s, one per line)
''')

    parser.add_argument('-v', '--verbose', action='count', default=0)
    parser.add_argument('-s', '--server', required=True, help='hostname of server')
    parser.add_argument('-p', '--port', help='port for h2 on server', default=443, type=int)
    parser.add_argument('-u', '--upstream-interface', help='receive interface for local network NATted traffic', required=True)
    parser.add_argument('-d', '--downstream-interface', help='transmit interface for de-NATted global traffic', required=True)

    args = parser.parse_args(args_in[1:])
    verbosity = None
    if args.verbose:
        verbosity = '-'+'v'*args.verbose

    control='/var/run/mnat/igmp-monitor.sgs'
    cacert ='/etc/mnat/ca.pem'
    clientcert ='/etc/mnat/client.pem'

    igmp_cmd = [
            '/usr/bin/stdbuf', '-oL', '-eL', 
            sys.executable, '/bin/mnat-igmp-monitor',
            '-i', args.downstream_interface,
            '-f', control,
        ]

    egress_cmd = [
            '/usr/bin/stdbuf', '-oL', '-eL', 
            sys.executable, '/bin/mnat-egress',
            '-i', args.upstream_interface,
            '-o', args.downstream_interface,
            '-s', args.server,
            '-p', str(args.port),
            '-f', control,
        ]

    if verbosity:
        igmp_cmd.append(verbosity)
        egress_cmd.append(verbosity)

    if isfile(cacert):
        egress_cmd.extend([
            '--cacert', cacert,
        ])

    if isfile(clientcert):
        egress_cmd.extend([
            '--cert', clientcert,
        ])

    igmp_p = subprocess.Popen(igmp_cmd)
    egress_p = subprocess.Popen(egress_cmd)

    igmp_ret, egress_ret = None, None
    while igmp_ret is None and egress_ret is None:
        igmp_ret = igmp_p.poll()
        egress_ret = egress_p.poll()
        time.sleep(1)

    if egress_ret is None:
        egress_p.kill(signal.SIGTERM)
    if igmp_ret is None:
        igmp_p.kill(signal.SIGTERM)

    return 0

if __name__=="__main__":
    ret = main(sys.argv)
    sys.exit(ret)

